#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrartcl
\begin_preamble
\usepackage{physics}
\addtokomafont{disposition}{\rmfamily}
\end_preamble
\options titlepage, abstract=true
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "times" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 0
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
GPU-Accelerated Particle Image Velocimetry
\end_layout

\begin_layout Subject
ME759 Final Project Report
\begin_inset Newline newline
\end_inset

University of Wisconsin-Madison
\end_layout

\begin_layout Author
Alex Ames
\end_layout

\begin_layout Abstract
lorem ipsum?
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Particle image velocimetry
\end_layout

\begin_layout Standard
In recent decades, particle image velocimetry has become an invaluable tool
 for studying the structure and properties of gas and liquid flows.
 By non-intrusively seeding a flow with a large number of small particles,
 then tracking the particles' displacement through multiple successive image
 frames, accurate velocity fields can be obtained.
 Although the technique was developed in the era of film cameras, with photograp
hic negatives digitized and then processed, PIV has come into its own with
 the widespread availability of digital cameras.
 
\end_layout

\begin_layout Standard
Traditional PIV algorithms work by dividing the images into a grid of sub-images
, then finding the inter-image displacements which maximize the correlation
 between each pair of sub-images.
 The simplest method of determining correlations is performing matrix multiplica
tion of the sub-image pairs at every possible displacement (with appropriate
 boundary padding), but this approach can require several hours of processing
 time for a single image pair.
 More sophisticated approaches use fast Fourier transform (FFT) routines
 to determine correlations in a matter of minutes, but the resultant velocity
 fields exhibit a phenomenon known as peak-locking due to single-pixel particles
, decreasing their accuracy 
\begin_inset CommandInset citation
LatexCommand cite
key "pust2000piv"

\end_inset

.
 To improve the resolution of the output velocity field, PIV algorithms
 typically overlap the search boxes and recursively decrease the searched
 area, using velocity fields from previous iterations to warp the second
 image
\end_layout

\begin_layout Section
Optical flow
\end_layout

\begin_layout Itemize
Computer vision often requires determination of displacement fields between
 video frames for motion detection or whatever
\end_layout

\begin_layout Itemize
Typically less rigorous algorithms than PIV: meant for real-time use with
 any heavy computation offloaded to graphics cards
\end_layout

\begin_layout Itemize
Popular method: Lucas-Kanade optical flow
\end_layout

\begin_deeper
\begin_layout Itemize
outline
\end_layout

\end_deeper
\begin_layout Itemize
Adapted for PIV by Frenchies
\end_layout

\begin_deeper
\begin_layout Itemize
their results
\end_layout

\end_deeper
\begin_layout Section
Julia image processing & GPU capabilities
\end_layout

\begin_layout Subsection
Julia overview
\end_layout

\begin_layout Itemize
Matlab-like syntax, but functions are compiled just ahead of runtime instead
 of being interpreted like Matlab (or Python).
 Sophisticated type system means it's possible to write fast code even for
 user-defined types: don't have to stick to float64 arrays for speed.
\end_layout

\begin_layout Itemize
Underneath the hood, function call chains are transpiled to LLVM, which
 can produce fast bytecode for almost any platform
\end_layout

\begin_layout Itemize
Thanks to recent efforts by Google to allow transpilation from LLVM to CUDA
 kernels, it's possible to write CUDA kernels directly in Julia.
\end_layout

\begin_layout Itemize
Built-in support for calling C/C++/Fortran libraries
\end_layout

\begin_layout Itemize
Bindings to the C API for both CUDA and OpenCL are being developed for Julia
\end_layout

\begin_layout Subsection
Implementing FOLKI in Julia
\end_layout

\begin_layout Itemize
Chose to use OpenCL due to its availability on virtually all platforms regardles
s of whether a GPU is installed
\end_layout

\begin_layout Itemize
It's weird
\end_layout

\begin_layout Itemize
Damn tricky
\end_layout

\begin_layout Itemize
I got snarled up by implementation details, trying to get realistic vector
 fields.
 Requires extensive validation of input parameters and more-sophisticated
 boundary handling.
\end_layout

\begin_layout Itemize
See: some results for several synthetic and real-world PIV images
\end_layout

\begin_layout Subsection
Results
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/alexames/Dropbox/College/759--finalproject/raw/piv1B/B001_1.tif
	lyxscale 30
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Synthetic image of particles tracking a strong vortex 
\begin_inset CommandInset citation
LatexCommand cite
key "stanislas2003main"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Benchmarking key components
\end_layout

\begin_layout Itemize
Per FOLKI iteration, operation counts for:
\end_layout

\begin_deeper
\begin_layout Itemize
Interpolation
\end_layout

\begin_deeper
\begin_layout Itemize
Note: Julia support for hardware image interpolation is still under development,
 per my discussion with the developers: https://github.com/JuliaGPU/OpenCL.jl/issu
es/28#issuecomment-347974643
\end_layout

\begin_layout Itemize
Convolution
\end_layout

\begin_layout Itemize
Matrix multiplication
\end_layout

\end_deeper
\begin_layout Itemize
These key operations have been benchmarked with:
\end_layout

\begin_deeper
\begin_layout Itemize
Single-thread
\end_layout

\begin_layout Itemize
Julia's threading constructs
\end_layout

\begin_layout Itemize
OpenCL-backed array lib
\end_layout

\begin_layout Itemize
ArrayFire
\end_layout

\end_deeper
\begin_layout Itemize
I purchased a external PCI-e enclosure to test GPU acc.eleration using a
 R9 270x, but Apple support for external GPUs is still incomplete.
 The device is recognized by the OS, but not by the OpenCL installation
\end_layout

\end_deeper
\begin_layout Section
Conclusions
\end_layout

\begin_layout Itemize
Well, it's fast and super cool, but kinks need to be worked out.
\end_layout

\begin_deeper
\begin_layout Itemize
To paraphrase, 
\begin_inset Quotes eld
\end_inset

make it right, then make it fast
\begin_inset Quotes erd
\end_inset

.
 It isn't correct enough yet to be worth optimizing.
 Benchmarks of key functions show ____ speedup should be possible.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "bibliography"
options "IEEEtran"

\end_inset


\end_layout

\end_body
\end_document
